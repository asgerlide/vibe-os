import { create } from "zustand";
import { persist } from "zustand/middleware";
import { Persona, SectionKey } from "./types";

interface PersonaStore {
  personas: Persona[];
  selectedPersonaId: string | null;
  editingSection: SectionKey | null;
  isRegenerating: boolean;
  
  // Actions
  selectPersona: (id: string | null) => void;
  upsertPersona: (persona: Persona) => void;
  setPersonas: (personas: Persona[]) => void;
  regenerateSection: (personaId: string, sectionKey: SectionKey, prompt?: string) => Promise<void>;
  addPersonaFromAI: () => Promise<void>;
  setEditingSection: (section: SectionKey | null) => void;
  deletePersona: (id: string) => void;
  duplicatePersona: (id: string) => void;
  clearPersonas: () => void;
}

export const usePersonaStore = create<PersonaStore>()(
  persist(
    (set, get) => ({
  personas: [],
  selectedPersonaId: null,
  editingSection: null,
  isRegenerating: false,

  selectPersona: (id) => set({ selectedPersonaId: id }),

  upsertPersona: (persona) =>
    set((state) => {
      const index = state.personas.findIndex((p) => p.id === persona.id);
      if (index >= 0) {
        const newPersonas = [...state.personas];
        newPersonas[index] = persona;
        return { personas: newPersonas };
      }
      return { personas: [...state.personas, persona] };
    }),

  regenerateSection: async (personaId, sectionKey, prompt) => {
    set({ isRegenerating: true });
    
    // Simulate AI regeneration with a delay
    await new Promise((resolve) => setTimeout(resolve, 1500));
    
    const { personas } = get();
    const persona = personas.find((p) => p.id === personaId);
    if (!persona) {
      set({ isRegenerating: false });
      return;
    }

    // Stub: Generate mock updated content based on section
    const updatedPersona = { ...persona };
    
    switch (sectionKey) {
      case "bio":
        updatedPersona.bio = `${persona.bio} [AI Enhanced: ${prompt || "Refined for clarity"}]`;
        break;
      case "goals":
        updatedPersona.goals = [
          ...persona.goals,
          {
            id: `goal-${Date.now()}`,
            text: "AI-suggested goal based on analysis",
            priority: 2 as const,
          },
        ];
        break;
      case "painPoints":
        updatedPersona.painPoints = [
          ...persona.painPoints,
          {
            id: `pain-${Date.now()}`,
            category: "functional" as const,
            text: "AI-identified pain point",
            severity: "medium" as const,
          },
        ];
        break;
      // Add more cases as needed
      default:
        break;
    }

    set((state) => ({
      personas: state.personas.map((p) =>
        p.id === personaId ? updatedPersona : p
      ),
      isRegenerating: false,
    }));
  },

  addPersonaFromAI: async () => {
    set({ isRegenerating: true });
    
    // Simulate AI generation
    await new Promise((resolve) => setTimeout(resolve, 2000));
    
    const newPersona: Persona = {
      id: `persona-${Date.now()}`,
      type: "Secondary",
      name: "AI Generated Persona",
      role: "Target User",
      age: 28,
      ageRange: "25-34",
      incomeRange: "$50k-$80k",
      company: "Tech Startup",
      industry: "Technology",
      location: "Remote",
      experienceLevel: "intermediate",
      techProficiency: "medium",
      matchScore: 75,
      bio: "This persona was generated by AI based on your workspace analysis. Edit to customize.",
      quickFacts: ["Early adopter", "Remote worker", "Values efficiency"],
      journey: [
        { id: "j1", title: "Discovery", status: "completed" },
        { id: "j2", title: "Evaluation", status: "active" },
        { id: "j3", title: "Adoption", status: "pending" },
      ],
      goals: [
        { id: "g1", text: "Streamline daily workflow", priority: 1 },
        { id: "g2", text: "Reduce context switching", priority: 2 },
      ],
      painPoints: [
        {
          id: "p1",
          category: "process",
          text: "Too many tools to manage",
          severity: "high",
        },
      ],
      behaviors: ["Research-driven", "Early morning worker"],
      tools: [{ id: "t1", name: "Notion", purpose: "Documentation" }],
      jtbds: [
        {
          id: "jtbd1",
          kind: "functional",
          title: "Organize tasks efficiently",
          detail: "When I have multiple projects, I want to see all tasks in one place",
        },
      ],
      needsMap: [
        { need: "Centralized workspace", solution: "All-in-one platform" },
      ],
      triggers: [{ id: "tr1", text: "Project deadline approaching" }],
      constraints: [{ id: "c1", text: "Limited budget" }],
      scenarios: [
        {
          id: "s1",
          title: "Daily planning",
          description: "Starts day by reviewing priorities",
          outcome: "positive",
        },
      ],
      goalPainSolutions: [
        {
          id: "gps-1",
          goal: { text: "Improve productivity", metric: "Tasks completed" },
          painPoints: [
            { id: "pp-1", text: "Too many tools to manage", severity: "high" as const },
          ],
          solution: { text: "Unified workspace", feature: "All-in-one dashboard" },
        },
      ],
      skills: [
        { skill: "Technical", level: 70 },
        { skill: "Communication", level: 65 },
        { skill: "Problem Solving", level: 75 },
        { skill: "Leadership", level: 50 },
        { skill: "Creativity", level: 60 },
      ],
      engagementData: [
        { label: "Week 1", value: 40 },
        { label: "Week 2", value: 55 },
        { label: "Week 3", value: 50 },
        { label: "Week 4", value: 65 },
      ],
    };

    set((state) => ({
      personas: [...state.personas, newPersona],
      isRegenerating: false,
    }));
  },

  setEditingSection: (section) => set({ editingSection: section }),

  deletePersona: (id) =>
    set((state) => ({
      personas: state.personas.filter((p) => p.id !== id),
      selectedPersonaId:
        state.selectedPersonaId === id ? null : state.selectedPersonaId,
    })),

  duplicatePersona: (id) =>
    set((state) => {
      const persona = state.personas.find((p) => p.id === id);
      if (!persona) return state;
      
      const duplicate: Persona = {
        ...persona,
        id: `persona-${Date.now()}`,
        name: `${persona.name} (Copy)`,
        type: "Secondary",
      };
      
      return { personas: [...state.personas, duplicate] };
    }),

  setPersonas: (personas) => set({ personas }),

  clearPersonas: () => set({ personas: [], selectedPersonaId: null }),
    }),
    {
      name: "persona-storage",
    }
  )
);
